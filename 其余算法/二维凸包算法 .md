### **二维平面点集的最小凸包算法**  
凸包（Convex Hull）是指包含给定点集的最小凸多边形。以下是几种经典算法及其特点：

---

### **1. Graham扫描法（Graham's Scan）**  
**核心思想**：  
• 选择最下方的点（$y$坐标最小）作为基点，按极角排序后逆时针扫描。  
• 利用**叉积**判断点的转向（左转保留，右转弹出栈顶）。  

**步骤**：  

1. 找到基点$P_0$（最低且最左的点）。  
2. 按$P_0$与其他点的极角排序（若极角相同，按距离排序）。  
3. 维护一个栈，依次检查点是否构成左转（叉积$>0$），否则弹出栈顶。  

**复杂度**：  
• 排序$O(n \log n)$，扫描$O(n)$，总复杂度$O(n \log n)$。  

**代码片段**（伪代码）：  
```python
def graham_scan(points):
    p0 = min(points, key=lambda p: (p.y, p.x))  # 找基点
    sorted_points = sorted(points, key=lambda p: (atan2(p.y-p0.y, p.x-p0.x), p))  # 极角排序
    stack = [p0, sorted_points[0]]
    for p in sorted_points[1:]:
        while len(stack) >= 2 and cross(stack[-2], stack[-1], p) <= 0:
            stack.pop()
        stack.append(p)
    return stack
```

---

### **2. Andrew算法（Andrew's Algorithm）**  
**改进点**：  
• 按$x$坐标排序后，分别求**下凸壳**和**上凸壳**，合并结果。  
• 避免极角排序，稳定性更高。  

**步骤**：  
1. 按$x$和$y$坐标排序。  
2. 正向扫描求下凸壳，反向扫描求上凸壳。  
3. 合并时去除重复点。  

**复杂度**：$O(n \log n)$。  

**优势**：适合处理共线点或重复点。  

---

### **3. Jarvis步进法（Jarvis March）**  
**核心思想**：  
• 类似“包裹礼物”，逐步寻找凸包的下一个顶点。  

**步骤**：  
1. 从最左点$P_0$开始。  
2. 每次选择极角最小的点$P_{i+1}$（用叉积判断）。  
3. 重复直到回到起点。  

**复杂度**：$O(nh)$，其中$h$为凸包顶点数，适合$h$较小的场景。  

---

### **4. 快速凸包法（QuickHull）**  
**思想**：分治法  
1. 找到最左、最右的点$A,B$，将点集分为两部分。  
2. 递归处理离线段$AB$最远的点$C$，抛弃三角形$ABC$内部的点。  

**复杂度**：平均$O(n \log n)$，最坏$O(n^2)$。  

---

### **算法对比**  
| 算法         | 时间复杂度    | 适用场景             |
| ------------ | ------------- | -------------------- |
| Graham扫描法 | $O(n \log n)$ | 通用，需极角排序     |
| Andrew算法   | $O(n \log n)$ | 稳定性高，适合共线点 |
| Jarvis步进法 | $O(nh)$       | 凸包顶点少时高效     |
| QuickHull    | $O(n \log n)$ | 分治思想，但最差较差 |

---

### **代码实现建议**  
• **Graham扫描法**：[参考百度百科示例](https://baike.baidu.com/item/葛立恒扫描法)。  
• **Andrew算法**：[洛谷专栏模板](https://www.luogu.com.cn)。  

如需具体实现细节或优化技巧，可进一步探讨！