在生成增强数据后，筛选高质量图像是提升模型性能的关键步骤。以下是基于评分估计的筛选方法，结合技术原理、代码示例和实践建议：

### **一、质量评估指标选择**

#### **1. 基于特征的相似度指标**

| **指标**  | **原理**                                                     | **适用场景**         |
| --------- | ------------------------------------------------------------ | -------------------- |
| **FID**   | 计算生成图像与真实图像在 Inception 模型特征空间的距离（越小越好） | 图像生成质量整体评估 |
| **LPIPS** | 基于预训练网络（如 VGG）的感知损失，衡量人类感知相似性（越小越好） | 视觉相似性优先的任务 |
| **IS**    | 计算生成图像类内熵与类间 KL 散度，评估多样性和真实性（越高越好） | 多样性需求高的任务   |

#### **2. 视觉质量指标**

| **指标** | **原理**                                                    | **工具** |
| -------- | ----------------------------------------------------------- | -------- |
| **PSNR** | 峰值信噪比，衡量像素级差异（越大越好）                      | OpenCV   |
| **SSIM** | 结构相似性指数，综合亮度、对比度和结构信息（越接近 1 越好） | skimage  |

#### **3. 任务相关指标**

- **分类任务**：用生成图像微调模型，评估验证集准确率。

- **检测任务**：计算生成图像上的 mAP@0.5。

### **二、自动化筛选流程**

#### **1. 评分模型构建**

```
import torch
from torchvision import models, transforms
from PIL import Image

class QualityScorer:
    def __init__(self):
        self.model = models.inception_v3(pretrained=True).eval()
        self.transform = transforms.Compose([
            transforms.Resize((299, 299)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
    
    def get_fid_score(self, real_imgs, fake_imgs):
        # 计算特征统计量
        real_feats = self.extract_features(real_imgs)
        fake_feats = self.extract_features(fake_imgs)
        # 计算FID（简化实现，实际需统计均值和协方差）
        return torch.norm(real_feats.mean(0) - fake_feats.mean(0))
    
    def extract_features(self, imgs):
        with torch.no_grad():
            return self.model(imgs)
```

#### **2. 筛选策略**

```
def select_augmented_images(real_dataset, fake_dataset, threshold=0.8):
    scorer = QualityScorer()
    selected = []
    
    for real_img, fake_img in zip(real_dataset, fake_dataset):
        # 计算FID分数
        fid = scorer.get_fid_score(real_img.unsqueeze(0), fake_img.unsqueeze(0))
        # 筛选高分样本
        if fid < threshold:
            selected.append(fake_img)
    
    return selected
```

### **三、结合任务的动态筛选**

#### **1. 训练 - 评估循环**

```
def iterative_selection(model, real_loader, fake_loader, iterations=5):
    for _ in range(iterations):
        # 用当前模型评估生成样本
        scores = []
        for real_batch, fake_batch in zip(real_loader, fake_loader):
            real_pred = model(real_batch)
            fake_pred = model(fake_batch)
            # 用预测置信度作为评分
            scores.append(torch.mean(fake_pred.softmax(dim=1).max(dim=1).values))
        
        # 选择Top-K%样本
        threshold = torch.quantile(torch.cat(scores), 0.9)
        filtered_fake = [img for img, score in zip(fake_loader.dataset, scores) if score > threshold]
    
    return filtered_fake
```

#### **2. 对抗筛选（结合 GAN）**

```
class Discriminator(nn.Module):
    def __init__(self):
        super().__init__()
        self.layers = nn.Sequential(
            nn.Conv2d(3, 64, 4, stride=2, padding=1),
            nn.LeakyReLU(0.2),
            nn.Conv2d(64, 128, 4, stride=2, padding=1),
            nn.BatchNorm2d(128),
            nn.LeakyReLU(0.2),
            nn.Flatten(),
            nn.Linear(128*7*7, 1)
        )
    
    def forward(self, x):
        return self.layers(x)

# 训练判别器
def train_discriminator(real_dataset, fake_dataset):
    discriminator = Discriminator()
    optimizer = optim.Adam(discriminator.parameters(), lr=1e-4)
    
    for epoch in range(10):
        for real_img, fake_img in zip(real_dataset, fake_dataset):
            real_pred = discriminator(real_img)
            fake_pred = discriminator(fake_img)
            loss = -torch.mean(torch.log(real_pred + 1e-8) + torch.log(1 - fake_pred + 1e-8))
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
    
    return discriminator

# 用判别器筛选
def filter_with_discriminator(discriminator, fake_dataset, threshold=0.5):
    filtered = []
    for img in fake_dataset:
        pred = discriminator(img.unsqueeze(0))
        if pred > threshold:  # 判别器认为更像真实图像
            filtered.append(img)
    return filtered
```

### **四、多维度筛选策略**

#### **1. 综合评分公式**

```
def comprehensive_score(fake_img, real_img):
    # 计算FID
    fid = compute_fid(fake_img, real_img)
    # 计算LPIPS
    lpips = compute_lpips(fake_img, real_img)
    # 计算分类置信度
    confidence = model(fake_img.unsqueeze(0)).softmax(dim=1).max(dim=1).values
    
    # 加权平均
    return 0.4 * fid + 0.3 * lpips + 0.3 * confidence
```

#### **2. 筛选阈值动态调整**

```
def adaptive_threshold(fake_scores, real_scores, alpha=0.1):
    # 计算真实数据分布的分位数
    real_quantile = torch.quantile(real_scores, 1 - alpha)
    # 筛选生成数据中高于该分位数的样本
    return fake_scores > real_quantile
```

### **五、实践建议**

#### **1. 硬件与性能优化**

- **加速特征提取**：使用 GPU 并行计算 FID/LPIPS。

- **缓存特征**：对真实数据预提取特征，避免重复计算。

#### **2. 领域特定优化**

- **医学影像**：结合 Dice 系数（结构相似性）和病灶定位准确性。

- **自动驾驶**：用目标检测模型评估生成图像中物体的位置和大小。

#### **3. 工具推荐**

| **工具**           | **功能**             | **链接**                                          |
| ------------------ | -------------------- | ------------------------------------------------- |
| **TensorFlow-GAN** | 提供 FID/IS 计算工具 | https://github.com/tensorflow/gan                 |
| **PyTorch-FID**    | 轻量级 FID 实现      | https://github.com/mseitzer/pytorch-fid           |
| **LPIPS-PyTorch**  | 感知损失计算         | https://github.com/richzhang/PerceptualSimilarity |

### **六、总结**

通过结合**特征相似度指标**（FID/LPIPS）、**任务相关评估**（分类置信度）和**对抗筛选**（GAN 判别器），可有效筛选高质量增强数据。建议采用多维度评分和动态阈值策略，在**多样性**和**真实性**之间取得平衡。对于特定领域任务，需定制化评估指标（如医学影像的病灶覆盖度）。